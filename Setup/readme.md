# MQTT Setup

We need to create a "docker" folder that will be a link between our local machine and the container. Inside we need 3 folders: ***log*** , ***data*** and ***config***

Inside the docker folder, create a docker-compose.yml file for our container with this command :

``` shell
nano docker-compose.yaml
```
Paste the following inside : 

``` shell
version: '3.5'

services:
  mosquitto:
    container_name: mos-Setup
    image: eclipse-mosquitto:latest
    volumes:
      - ./config:/mosquitto/config
      - ./log:/mosquitto/log
      - ./data:/mosquitto/data
    ports:
      - '1883:1883'
    networks:
      - default
    restart: unless-stopped

networks:
  default:
```
Inside the ***config*** folder, create a **mosquitto.conf** file with the command : 

``` shell
touch mosquitto.conf
```

Add these lines inside the document with a text editor : 

``` shell
persistence true
persistence_location /mosquitto/data/
log_dest file /mosquitto/log/mosquitto.log
```

At this point, the only connections allowed are local connections. Add these two lines to allow the connection of the **raspberry** to our **broker**:

``` shell
allow_anonymous true
listener 1883
```

Ultimately, it will be necessary to remove ***allow_anonymous*** to set up an authentication system.

## Test de l'environnement


To start docker the first time, you must execute this command in the docker folder:

``` shell
sudo docker-compose up
```

<br/>

## Python Scripts

To test the correct functioning of the broker, you must create python scripts which will act as MQTT Subscribers and MQTT Publishers

The publisher will therefore be the Raspberry pi and the subscriber will be another instance of the terminal. We will use [Python 3.11.2](https://www.python.org/downloads/release/python-3112/) and [Paho Python Client](https://www.eclipse.org/paho/index.php?page=clients/python/index.php)

You must therefore install Paho with the following command:

``` shell
pip install paho-mqtt
```

#### Publisher

This python file must be located on the Raspberry.

In a new python file `client.py` we add the Paho and Time libraries.

``` python
import paho.mqtt.client as mqtt
import time
```

Then we create a function to execute when connecting to the broker:

``` python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)
```

You must then connect to the broker by specifying the **hostname** and its **port**. Here, the hostname is the IP address of the machine that hosts the broker.

You must then create a client with a unique identifier. We can use the `ip a` command to retrieve our ip address, and we will use **Client1** as the client name:

```python
broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Customer1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()
```

To publish messages, we will do an infinite loop which will publish a new message every second. For Paho, you must indicate the subject of the message, so that subscribers can subscribe to these subjects.

We then add `loop_stop()` to clean up the Paho thread and free the memory.

```python
topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

By launching the script, we will have in the console:
```shell
connected
Message 1 is published to topic Test 
Message 2 is published to topic Test 
Message 3 is published to topic Test 
Message 4 is published to topic Test 
Message 5 is published to topic Test
```

Find below the complete structure of the file:

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)

broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Client1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()

topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

#### Subscriber

The structure of the `sub.py` file is almost identical to that of the publisher.

So we have the same libraries:
```python
import paho.mqtt.client as mqtt import time
```

In the `on_connect` function we subscribe to a subject, here the Test subject, with the **subscribe** function:

```python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)
```

When the subscriber receives a message from the broker, he invokes the `on_message` function, we define it like this:
```python
def on_message(client, userdata, message):
	print("Received message: " ,str(message.payload.decode("utf-8")))
```

We then define the **hostname** and the **port**. Since this file is an instance of the terminal coming from the same machine as the broker, we can therefore fill in:

```python
broker_hostname ="localhost"
port = 1883
```

We create a client instance as before, but with Client2:

```python
client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Here is the code in full:

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)


def on_message(client, userdata, message):
    print("Received message: " ,str(message.payload.decode("utf-8")))


broker_hostname ="0.0.0.0"
port = 1883

client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Normally, we find in the console:

``` shell
Received message: 1
Received message: 2 
Received message: 3 
Received message: 4 
Received message: 5
```

Our initial configuration is done. 

You can then find the differents attacks done on MQTT here :

 - [Bruteforce](https://github.com/Souf31/mqtt-pentest/tree/main/Bruteforce)
 - [Denial of Service](https://github.com/Souf31/mqtt-pentest/tree/main/DOS)
 - [TLS](https://github.com/Souf31/mqtt-pentest/tree/main/TLS)
