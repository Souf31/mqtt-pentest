# Configuration MQTT

## Prérequis

J'étais sur une VM [Kali](https://www.kali.org/get-kali/#kali-platforms) à jour. On utilisera [Docker](https://www.docker.com/) pour y installer notre Broker MQTT.

Il faut créer un dossier "mosquitto" qui servira de lien entre le dossier local et le conteneur. Dedans, il faudra y trouver trois dossier : ***log*** , ***data*** et ***config**

Une fois dans le dossier ***config***, téléchargez le template du document **mosquitto.conf** avec la commande : 

``` shell
wget https://raw.githubusercontent.com/eclipse/mosquitto/master/mosquitto.conf
```

Il faut ensuite rajouter ces lignes a la fin du fichier **.conf** :

``` shell
persistence true
persistence_location /mosquitto/data/
log_dest file /mosquitto/log/mosquitto.log
```

À ce stade, les seules connexion autorisées sont des connexions locales. Ces deux lignes permettent la connexion du **raspberry** à notre **broker** : 

``` shell
allow_anonymous true
listener 1883
```

À terme il faudra retirer ***allow_anonymous*** pour mettre en place un système d'authentification. 

## Test de l'environnement


Pour démarrer le docker la première fois, il faut executer cette commande : 

``` shell
sudo docker run -it --name mos1 -p 1883:1883 -p 9001:9001 -v /home/kali/mqtt-broker/mosquitto/:/mosquitto/ eclipse-mosquitto
```

Les fois suivantes, il suffit de démarrer ou d'arreter le conteneur avec ces commandes : 

##### Start :

``` shell
sudo docker start mos1
```

##### Stop : 

``` shell
sudo docker stop mos1
```
<br/>
<br/>
Pour vérifier si le conteneur est en cours d'execution, on peut utiliser la commande suivante : 

``` shell
sudo docker ps -a
```

<br/>

## Scripts Python

Pour tester le bon fonctionnement du broker, il faut créer des scripts python qui vont agir comme des MQTT Subscribers et MQTT Publishers

Le publisher sera donc le Raspberry pi et le subscriber sera une autre instance du terminal. On utilisera [Python 3.11.2](https://www.python.org/downloads/release/python-3112/) et [Paho Python Client](https://www.eclipse.org/paho/index.php?page=clients/python/index.php)

Il faut donc installer Paho avec la commande suivante : 

``` shell
pip install paho-mqtt
```

#### Publisher

Ce fichier python doit donc se trouver sur le Raspberry.

Dans un nouveau fichier python `client.py` on ajoute la librairie Paho et Time.

``` python
import paho.mqtt.client as mqtt
import time
```

Ensuite on crée une fonction a executer lors de la connexion au broker : 

``` python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)
```

Il faut ensuite se connecter à notre broker en spécifiant le **hostname** et son **port**. Ici, le hostname est donc l'adresse IP de la machine qui host le broker. 

Il faut ensuite créer un client avec un identifiant unique.  On peut utiliser la commande `ip a` pour la récupérer, et on utilisera comme nom de client **Client1** :

```python
broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Client1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()
```

Pour publier des messages, on fera une boucle infinie qui publiera un nouveau message toutes les secondes. Pour Paho, il faut indiquer le sujet du message, pour que les subscriber peuvent s'abonner à ces sujets.

On ajoute ensuite `loop_stop()` pour nettoyer le thread Paho et libérer la mémoire.

```python
topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

En lançant le script, on aura donc dans la console :
```shell
connected
Message 1 is published to topic Test 
Message 2 is published to topic Test 
Message 3 is published to topic Test 
Message 4 is published to topic Test 
Message 5 is published to topic Test
```

Ci-dessous la structure complete du fichier : 

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)

broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Client1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()

topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

#### Subscriber

La structure du fichier `sub.py` est presque identique à celle du publisher.

On a donc les mêmes librairies : 
```python
import paho.mqtt.client as mqtt import time
```

Dans la fonction `on_connect` on s'abonne à un sujet, ici le sujet Test, avec la fonction **subscribe** :

```python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)
```

Lorsque l'abonné reçoit un message du broker, il invoque la fonction `on_message`, on la définit comme ceci : 
```python
def on_message(client, userdata, message):
	print("Received message: " ,str(message.payload.decode("utf-8")))
```

On définit ensuite le **hostname** et le **port**. Puisque ce fichier est une instance du terminal provenant de la même machine que le broker, on peut donc remplir : 

```python
broker_hostname ="localhost"
port = 1883
```

On crée une instance de client comme précédemment, mais avec Client2 :

```python
client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Voici le code en entier :

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)


def on_message(client, userdata, message):
    print("Received message: " ,str(message.payload.decode("utf-8")))


broker_hostname ="0.0.0.0"
port = 1883

client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Normalement, on trouve dans la console : 

``` shell
Received message: 1
Received message: 2 
Received message: 3 
Received message: 4 
Received message: 5
```

# Pentest MQTT
## Not encrypted 

Since MQTT is **not encrypted**, if there is no authentication method anyone can either **listen** or **publish** if he has access to the Broker IP Address. 

All it takes is one Nmap scan to know the MQTT port.

### Nmap

You can use the [nmap](https://nmap.org/) tool to scan an IP Address. You can use this command to scan the ports:

``` shell
nmap -sC -sV -p- <ip>
```
## Brute Force Attack

### Authentication Settings

First off, we need to remove anonymous authentication from the MQTT Broker. To do so, add these lines to the **mosquitto.conf** file : 

``` shell
password_file /mosquitto/passwd_file
allow_anonymous false
```

Then, we need to create a **passw_file** and add **username:password** encrypted combinations. Go into the docker cmd and run these commands :

***Create passwd_file*** :

```
mosquitto_passwd -c passwordfile user
```

This will add a user to the file. To set its password, run this command :

```
mosquitto_passwd -b passwordfile user password
```

We created three users : 

**admin:root**
**username:password**
**anna:spiderman**
### Metasploit

We will use a Metasploit payload to demonstrate that even beginners can hack poorly setup MQTT Brokers.

We will use the payload.
To use it, we simply need to give him some infos such as : 

**RHOST** : IP Address of the broker
**PASS_FILE** : file containing a list of passwords
**USERS_FILE** : file containing a list of usernames

#### Exploit

Start Metasploit using this command in a Linux CMD :

```shell
msfconsole
```

Then, run these commands in Metasploit : 

```shell
use auxiliary/scanner/mqtt/connect
```

```shell
set PASS_FILE <your_password_file>
set USER_FILE <your_users_file>
set RHOSTS <broker_ip_address>
```

and then : 
``` shell
run
```

After a while, here is the result: (we stopped at the the first hit or it would take forever)

![mqtt sucesss](https://media.discordapp.net/attachments/469531451696742410/1138525348347265024/Pasted_image_20230808192512.png?width=1728&height=898 "mqtt sucesss")

### Go further 

*Maybe retrieve password file and try johntheripper?*
### Conclusion

There's no security against Brute Force on IOT Devices credentials. You can either secure your devices placing them behind Firewalls and WAF, but you **MUST** use strong IOT Credentials.

## DOS Attack
