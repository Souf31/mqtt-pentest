# MQTT Configuration

## Prerequisite

All this work was done on a [Kali](https://www.kali.org/get-kali/#kali-platforms) VM up to date. We will use [Docker](https://www.docker.com/) for our MQTT Broker.

We need to create a "moquitto" folder that will be a link between our local machine and the container. Inside we need 3 folders: ***log*** , ***data*** and ***config**

Inside the ***config*** folder, create a **mosquitto.conf** file with the command : 

``` shell
touch mosquitto.conf
```

Add these lines inside the document with a text editor : 

``` shell
persistence true
persistence_location /mosquitto/data/
log_dest file /mosquitto/log/mosquitto.log
```

At this point, the only connections allowed are local connections. Add these two lines to allow the connection of the **raspberry** to our **broker**:

``` shell
allow_anonymous true
listener 1883
```

Ultimately, it will be necessary to remove ***allow_anonymous*** to set up an authentication system.

## Test de l'environnement


To start docker the first time, you must execute this command:

``` shell
sudo docker run -it --name mos1 -p 1883:1883 -p 9001:9001 -v /home/kali/mqtt-broker/mosquitto/:/mosquitto/ eclipse-mosquitto
```

The following times, simply start or stop the container with these commands:

##### Start:

``` shell
sudo docker start mos1
```

##### Stop:

``` shell
sudo docker stop mos1
```
<br/>
<br/>
To check if the container is running, you can use the following command:

``` shell
sudo docker ps -a
```

<br/>

## Python Scripts

To test the correct functioning of the broker, you must create python scripts which will act as MQTT Subscribers and MQTT Publishers

The publisher will therefore be the Raspberry pi and the subscriber will be another instance of the terminal. We will use [Python 3.11.2](https://www.python.org/downloads/release/python-3112/) and [Paho Python Client](https://www.eclipse.org/paho/index.php?page=clients/python/index.php)

You must therefore install Paho with the following command:

``` shell
pip install paho-mqtt
```

#### Publisher

This python file must be located on the Raspberry.

In a new python file `client.py` we add the Paho and Time libraries.

``` python
import paho.mqtt.client as mqtt
import time
```

Then we create a function to execute when connecting to the broker:

``` python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)
```

You must then connect to the broker by specifying the **hostname** and its **port**. Here, the hostname is the IP address of the machine that hosts the broker.

You must then create a client with a unique identifier. We can use the `ip a` command to retrieve it, and we will use **Client1** as the client name:

```python
broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Customer1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()
```

To publish messages, we will do an infinite loop which will publish a new message every second. For Paho, you must indicate the subject of the message, so that subscribers can subscribe to these subjects.

We then add `loop_stop()` to clean up the Paho thread and free the memory.

```python
topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

By launching the script, we will have in the console:
```shell
connected
Message 1 is published to topic Test 
Message 2 is published to topic Test 
Message 3 is published to topic Test 
Message 4 is published to topic Test 
Message 5 is published to topic Test
```

Find below the complete structure of the file:

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)

broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Client1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()

topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

#### Subscriber

The structure of the `sub.py` file is almost identical to that of the publisher.

So we have the same libraries:
```python
import paho.mqtt.client as mqtt import time
```

In the `on_connect` function we subscribe to a subject, here the Test subject, with the **subscribe** function:

```python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)
```

When the subscriber receives a message from the broker, he invokes the `on_message` function, we define it like this:
```python
def on_message(client, userdata, message):
	print("Received message: " ,str(message.payload.decode("utf-8")))
```

We then define the **hostname** and the **port**. Since this file is an instance of the terminal coming from the same machine as the broker, we can therefore fill in:

```python
broker_hostname ="localhost"
port = 1883
```

We create a client instance as before, but with Client2:

```python
client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Here is the code in full:

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)


def on_message(client, userdata, message):
    print("Received message: " ,str(message.payload.decode("utf-8")))


broker_hostname ="0.0.0.0"
port = 1883

client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Normally, we find in the console:

``` shell
Received message: 1
Received message: 2 
Received message: 3 
Received message: 4 
Received message: 5
```

# Pentest MQTT
## Not encrypted 

Since MQTT is **not encrypted**, if there is no authentication method anyone can either **listen** or **publish** if he has access to the Broker IP Address. 

All it takes is one Nmap scan to know the MQTT port.

### Nmap

You can use the [nmap](https://nmap.org/) tool to scan an IP Address. You can use this command to scan the ports:

``` shell
nmap -sC -sV -p- <ip>
```
## Brute Force Attack

### Authentication Settings

First off, we need to remove anonymous authentication from the MQTT Broker. To do so, add these lines to the **mosquitto.conf** file : 

``` shell
password_file /mosquitto/passwd_file
allow_anonymous false
```

Then, we need to create a **passw_file** and add **username:password** encrypted combinations. Go into the docker cmd and run these commands :

***Create passwd_file*** :

```
mosquitto_passwd -c passwordfile user
```

This will add a user to the file. To set its password, run this command :

```
mosquitto_passwd -b passwordfile user password
```

We created three users : 

**admin:root**
**username:password**
**anna:spiderman**
### Metasploit

We will use a Metasploit payload to demonstrate that even beginners can hack poorly setup MQTT Brokers.

We will use the payload.
To use it, we simply need to give him some infos such as : 

**RHOST** : IP Address of the broker
**PASS_FILE** : file containing a list of passwords
**USERS_FILE** : file containing a list of usernames

#### Exploit

Start Metasploit using this command in a Linux CMD :

```shell
msfconsole
```

Then, run these commands in Metasploit : 

```shell
use auxiliary/scanner/mqtt/connect
```

```shell
set PASS_FILE <your_password_file>
set USER_FILE <your_users_file>
set RHOSTS <broker_ip_address>
```

and then : 
``` shell
run
```

After a while, here is the result: (we stopped at the the first hit or it would take forever)

![mqtt sucesss](https://media.discordapp.net/attachments/469531451696742410/1138525348347265024/Pasted_image_20230808192512.png?width=1728&height=898 "mqtt sucesss")

### Go further 

*Maybe retrieve password file and try johntheripper?*
### Conclusion

There's no security against Brute Force on IOT Devices credentials. You can either secure your devices placing them behind Firewalls and WAF, but you **MUST** use strong IOT Credentials.

## DOS Attack

### Prerequisite

First, we need to remove the authentication so we can connect as many clients as possible. To do so, change the **mosquitto.conf** from ```

```
allow_anonymous false
```

to
```
allow_anonymous true
```

Then, to start the DOS attack we will need to customize our messages payload. To do so, we will use [krylovsk/mqtt-benchmark's](https://github.com/krylovsk/mqtt-benchmark) tool. You can either build the application using GO (Linux) , or download the .exe in the [release](https://github.com/krylovsk/mqtt-benchmark/releases/tag/v0.2.0) tab (Windows).
### Attack

First, we start the Docker container using :

```
docker start <containerID>
```


Once downloaded, we can start using the **mqtt-benchmark** tool using this manual : 
``` shell
$ ./mqtt-benchmark -h
Usage of ./mqtt-benchmark:
  -broker string
    	MQTT broker endpoint as scheme://host:port (default "tcp://localhost:1883")
  -broker-ca-cert string
    	Path to broker CA certificate in PEM format
  -client-cert string
    	Path to client certificate in PEM format
  -client-key string
    	Path to private clientKey in PEM format
  -client-prefix string
    	MQTT client id prefix (suffixed with '-<client-num>' (default "mqtt-benchmark")
  -clients int
    	Number of clients to start (default 10)
  -count int
    	Number of messages to send per client (default 100)
  -format string
    	Output format: text|json (default "text")
  -insecure
    	Skip TLS certificate verification
  -message-interval int
    	Time interval in seconds to publish message (default 1)
  -password string
    	MQTT client password (empty if auth disabled)
  -payload string
    	MQTT message payload. If empty, then payload is generated based on the size parameter
  -qos int
    	QoS for published messages (default 1)
  -quiet
    	Suppress logs while running
  -ramp-up-time int
    	Time in seconds to generate clients by default will not wait between load request
  -size int
    	Size of the messages payload (bytes) (default 100)
  -topic string
    	MQTT topic for outgoing messages (default "/test")
  -username string
    	MQTT client username (empty if auth disabled)
  -wait int
    	QoS 1 wait timeout in milliseconds (default 60000)
```

For testing, we try this command : 
``` shell
./mqtt-benchmark --broker tcp://localhost:1883 --count 10 --size 100 --clients 10 --qos 2 --format text
```

And we get this output :

``` shell
======= CLIENT 2 =======
Ratio:               1.000 (10/10)
Runtime (s):         10.011
Msg time min (ms):   1.286
Msg time max (ms):   3.478
Msg time mean (ms):  1.918
Msg time std (ms):   0.710
Bandwidth (msg/sec): 0.999

======= CLIENT 3 =======
Ratio:               1.000 (10/10)
Runtime (s):         10.011
Msg time min (ms):   1.305
Msg time max (ms):   4.008
Msg time mean (ms):  1.936
Msg time std (ms):   0.850
Bandwidth (msg/sec): 0.999

... etc.
```

We see that our broker has no issue handling 10 clients that send 10 messages with a message payload of 100 Bytes.

When we use a payload size of 100MB, with a 100 clients that send 10 messages each, the container has trouble keeping up and crashes. We used this command :

``` shell
./mqtt-benchmark --broker tcp://localhost:1883 --count 10 --size 100000000 --clients 100 --qos 2 --format text
```

and got this output : 
``` shell
...
2023/09/06 15:43:38 CLIENT 84 is connected to the broker tcp://localhost:1883
2023/09/06 15:43:46 CLIENT 20 is connected to the broker tcp://localhost:1883
2023/09/06 15:43:46 CLIENT 13 is connected to the broker tcp://localhost:1883
Killed

$
```

Using an extension that monitors our container, we can see that the CPU is the point of failure here, but the memory can also be critical if there's not enough ressources allocated to the container.

This is the easiest implementation of the DOS Attack, but reading documentation we can create custom MQTT messages that uses the protocol's QoS to crash the container.

### Going Further

There was an update for MQTT brokers recently : 2.0.16 (16/08/2023) that fixed some issues about MQTT. Since it's recent, chances are most of the brokers are not updated, leaving huge risks for attackers.

For previous version, such as 2.0.15, there was a vulnerability that took advantage of MQTT QoS policy that causes the broker to memory leak. 

Put simply, clients could send multiple QoS 2 messages with the same message ID, but then never respond to the PUBREC commands from the broker, leaving the 4 time handshake waiting for an answer. [## CVE-2023-27366](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-27366)

This is maybe something that can be tested during IoT exercise, by manufacturing message payloads and not allowing the publisher to respond to PUBREC. ***scapy?***

## MITM Attack

### Prerequisite

In this part, we will first demonstrate how an attacker can inspect unencrypted MQTT traffic, and in a second part see how to modify a MQTT payload using a proxy.

### Inspect traffic

To inspect the traffic, we will use [Wireshark](https://www.wireshark.org/). We cannot inspect local traffic in Wireshark, so we use a remote RaspberryPi to act as a publisher for our testing.

In Wireshark, we inspect the traffic on our network interface. Then we apply a filter to list only MQTT traffic. If the communication is not encrypted, we have this : 

![](https://cedalo.com/wp-content/uploads/2022/07/fig01.png)

We can this that everything is readable in Wireshark, not only the payload but the whole packet structure. We can also see the password used by a client to connect to a broker.

### Data modification

Some test done with IOXY showed how easy it is to edit MQTT packets that are not encrypted.

If we want to secure our data, we will need to use **MQTTS**. We need to encrypt our data using TLS.

## TLS Encryption

We will need to create our own self-signed certificates for this, but in a professional environment we will need ceritificates signed by a trusted third-party.

### Certificates

Have the **openssl** package installed

`sudo apt-get install openssl`

**CA Cert** : 

    openssl genrsa -out ca.key 2048 
    openssl req -new -x509 -days 365 -key ca.key -out ca.crt

**Serv Cert :** this certificate is the most important for this configuration

It needs to have differents informations than the one you chose for the CA certificate. 
More importantly, the IP of the broker needs to be in the CN and SAN fields. 

 - If you want to do it with your localhost, use **127.0.0.1**
 - Otherwise, use your local IP Address, mine is **192.168.129.2**

To do so:

    openssl genrsa -out server.key 2048
    openssl req -new -key server.key -out server.csr

**Remember to fill the CN with the IP address !**

-> add command for SAN

**And here is the command for the SAN field of the server certificate.**

We will implement the TLS so the clients have to authenticate using a certificate. 

**To do so, we need to create a certificate for each clients.**

Here we will use one Paho client as both the publisher and subscriber, so we only need one certificate.

**Client cert**: 

    openssl genrsa -out client.key 2048
    openssl req -new -key client.key -out client.csr
    openssl x509 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt

Once the certificates are created, we need to edit the broker for it to support TLS. We will use docker-compose to run our docker.

### Docker configuration

Here is the structure of the mounted volume :

    ├── config
    
    │ ├── certs
    
    │ │ ├── ca.crt
    
    │ │ ├── server.crt
    
    │ │ └── server.key
    
    │ └── mosquitto.conf

Here is the **mosquitto.conf** file :

    port 8883
    
    cafile /mosquitto/config/certs/ca.crt
    
    certfile /mosquitto/config/certs/server.crt
    
    keyfile /mosquitto/config/certs/server.key
    
    require_certificate true
    
    use_identity_as_username true

TLS uses the port **8883** by default. 
We also put the certs files in the cert folder, but make sure the server.key file is **readable by the Mosquitto user**.

To do so, run this command: `chown a+r ./config/certs/server.key`

Here is the docker-compose.yml file :

    version: '3.5'
    
    services:
    
    mosquitto:
    
    container_name: mosquitto_container
    
    image: eclipse-mosquitto:latest
    
    volumes:
    
    - ./config:/mosquitto/config/
    
    ports:
    
    - '8883:8883'
    
    networks:
    
    - default
    
    restart: unless-stopped
    
    networks:
    
    default:

To start the docker, we use the command docker-compose up.

### Client configuration

We again use the Paho library to communicate with the broker.

We create a new client tls.py. Here is the file : <insert file>

**The IP Address needs to be identical to the CN of the server certificate !**

We can see that we use TLS v1.2 with this line. <tls line>

Make sure that you can access the certificates from the python file : <cert files>

Connect to the client using `python3 tls.py`

### Traffic Inspection

Now if we want to inspect the traffic, we can use **Wireshark** again. 

![Image](https://media.discordapp.net/attachments/469531451696742410/1197227972319518720/image.png?ex=65ccf570&is=65ba8070&hm=0d61a83a09784ee9972857d0a4537844605e73b7aa63d31bb74dcb94555a3298&=&format=webp&quality=lossless&width=1440&height=233)

We can see that the traffic is using **TLSv1.2**. When we try to inspect it, we have no more information : ![Image](https://media.discordapp.net/attachments/469531451696742410/1197227648825430036/image.png?ex=65ccf522&is=65ba8022&hm=e442a6305420548cb3de9a248e0a4a9fbf0d0cfa05797ff893d0ddce417d6722&=&format=webp&quality=lossless&width=1098&height=600)

The traffic is now secured.
