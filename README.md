# Configuration MQTT

## Prérequis

J'étais sur une VM [Kali](https://www.kali.org/get-kali/#kali-platforms) à jour. On utilisera [Docker](https://www.docker.com/) pour y installer notre Broker MQTT.

Il faut créer un dossier "mosquitto" qui servira de lien entre le dossier local et le conteneur. Dedans, il faudra y trouver trois dossier : ***log*** , ***data*** et ***config**

Une fois dans le dossier ***config***, téléchargez le template du document **mosquitto.conf** avec la commande : 

``` shell
wget https://raw.githubusercontent.com/eclipse/mosquitto/master/mosquitto.conf
```

Il faut ensuite rajouter ces lignes a la fin du fichier **.conf** :

``` shell
persistence true
persistence_location /mosquitto/data/
log_dest file /mosquitto/log/mosquitto.log
```

À ce stade, les seules connexion autorisées sont des connexions locales. Ces deux lignes permettent la connexion du **raspberry** à notre **broker** : 

``` shell
allow_anonymous true
listener 1883
```

À terme il faudra retirer ***allow_anonymous*** pour mettre en place un système d'authentification. 

## Test de l'environnement


Pour démarrer le docker la première fois, il faut executer cette commande : 

``` shell
sudo docker run -it --name mos1 -p 1883:1883 -p 9001:9001 -v /home/kali/mqtt-broker/mosquitto/:/mosquitto/ eclipse-mosquitto
```

Les fois suivantes, il suffit de démarrer ou d'arreter le conteneur avec ces commandes : 

##### Start :

``` shell
sudo docker start mos1
```

##### Stop : 

``` shell
sudo docker stop mos1
```
<br/>
<br/>
Pour vérifier si le conteneur est en cours d'execution, on peut utiliser la commande suivante : 

``` shell
sudo docker ps -a
```

<br/>

## Scripts Python

Pour tester le bon fonctionnement du broker, il faut créer des scripts python qui vont agir comme des MQTT Subscribers et MQTT Publishers

Le publisher sera donc le Raspberry pi et le subscriber sera une autre instance du terminal. On utilisera [Python 3.11.2](https://www.python.org/downloads/release/python-3112/) et [Paho Python Client](https://www.eclipse.org/paho/index.php?page=clients/python/index.php)

Il faut donc installer Paho avec la commande suivante : 

``` shell
pip install paho-mqtt
```

#### Publisher

Ce fichier python doit donc se trouver sur le Raspberry.

Dans un nouveau fichier python `client.py` on ajoute la librairie Paho et Time.

``` python
import paho.mqtt.client as mqtt
import time
```

Ensuite on crée une fonction a executer lors de la connexion au broker : 

``` python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)
```

Il faut ensuite se connecter à notre broker en spécifiant le **hostname** et son **port**. Ici, le hostname est donc l'adresse IP de la machine qui host le broker. 

Il faut ensuite créer un client avec un identifiant unique.  On peut utiliser la commande `ip a` pour la récupérer, et on utilisera comme nom de client **Client1** :

```python
broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Client1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()
```

Pour publier des messages, on fera une boucle infinie qui publiera un nouveau message toutes les secondes. Pour Paho, il faut indiquer le sujet du message, pour que les subscriber peuvent s'abonner à ces sujets.

On ajoute ensuite `loop_stop()` pour nettoyer le thread Paho et libérer la mémoire.

```python
topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

En lançant le script, on aura donc dans la console :
```shell
connected
Message 1 is published to topic Test 
Message 2 is published to topic Test 
Message 3 is published to topic Test 
Message 4 is published to topic Test 
Message 5 is published to topic Test
```

Ci-dessous la structure complete du fichier : 

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
    else:
        print("could not connect, return code:", return_code)

broker_hostname = "192.168.0.90"
port = 1883

client = mqtt.Client("Client1")
client.on_connect=on_connect

client.connect(broker_hostname, port)
client.loop_start()

topic = "Test"
msg_count = 0

try:
    while msg_count < 100:
        time.sleep(1)
        msg_count += 1
        result = client.publish(topic, msg_count)
        status = result[0]
        if status == 0:
            print("Message "+ str(msg_count) + " is published to topic " + topic)
        else:
            print("Failed to send message to topic " + topic)
finally:
    client.loop_stop()
```

#### Subscriber

La structure du fichier `sub.py` est presque identique à celle du publisher.

On a donc les mêmes librairies : 
```python
import paho.mqtt.client as mqtt import time
```

Dans la fonction `on_connect` on s'abonne à un sujet, ici le sujet Test, avec la fonction **subscribe** :

```python
def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)
```

Lorsque l'abonné reçoit un message du broker, il invoque la fonction `on_message`, on la définit comme ceci : 
```python
def on_message(client, userdata, message):
	print("Received message: " ,str(message.payload.decode("utf-8")))
```

On définit ensuite le **hostname** et le **port**. Puisque ce fichier est une instance du terminal provenant de la même machine que le broker, on peut donc remplir : 

```python
broker_hostname ="localhost"
port = 1883
```

On crée une instance de client comme précédemment, mais avec Client2 :

```python
client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Voici le code en entier :

```python
import paho.mqtt.client as mqtt
import time

def on_connect(client, userdata, flags, return_code):
    if return_code == 0:
        print("connected")
        client.subscribe("Test")
    else:
        print("could not connect, return code:", return_code)


def on_message(client, userdata, message):
    print("Received message: " ,str(message.payload.decode("utf-8")))


broker_hostname ="0.0.0.0"
port = 1883

client = mqtt.Client("Client2")
client.on_connect=on_connect
client.on_message=on_message

client.connect(broker_hostname, port)
client.loop_start()

try:
    time.sleep(10)
finally:
    client.loop_stop()
```

Normalement, on trouve dans la console : 

``` shell
Received message: 1
Received message: 2 
Received message: 3 
Received message: 4 
Received message: 5
```

# Pentest MQTT
## Not encrypted 

Since MQTT is **not encrypted**, if there is no authentication method anyone can either **listen** or **publish** if he has access to the Broker IP Address. 

All it takes is one Nmap scan to know the MQTT port.

### Nmap

You can use the [nmap](https://nmap.org/) tool to scan an IP Address. You can use this command to scan the ports:

``` shell
nmap -sC -sV -p- <ip>
```
## Brute Force Attack

### Authentication Settings

First off, we need to remove anonymous authentication from the MQTT Broker. To do so, add these lines to the **mosquitto.conf** file : 

``` shell
password_file /mosquitto/passwd_file
allow_anonymous false
```

Then, we need to create a **passw_file** and add **username:password** encrypted combinations. Go into the docker cmd and run these commands :

***Create passwd_file*** :

```
mosquitto_passwd -c passwordfile user
```

This will add a user to the file. To set its password, run this command :

```
mosquitto_passwd -b passwordfile user password
```

We created three users : 

**admin:root**
**username:password**
**anna:spiderman**
### Metasploit

We will use a Metasploit payload to demonstrate that even beginners can hack poorly setup MQTT Brokers.

We will use the payload.
To use it, we simply need to give him some infos such as : 

**RHOST** : IP Address of the broker
**PASS_FILE** : file containing a list of passwords
**USERS_FILE** : file containing a list of usernames

#### Exploit

Start Metasploit using this command in a Linux CMD :

```shell
msfconsole
```

Then, run these commands in Metasploit : 

```shell
use auxiliary/scanner/mqtt/connect
```

```shell
set PASS_FILE <your_password_file>
set USER_FILE <your_users_file>
set RHOSTS <broker_ip_address>
```

and then : 
``` shell
run
```

After a while, here is the result: (we stopped at the the first hit or it would take forever)

![mqtt sucesss](https://media.discordapp.net/attachments/469531451696742410/1138525348347265024/Pasted_image_20230808192512.png?width=1728&height=898 "mqtt sucesss")

### Go further 

*Maybe retrieve password file and try johntheripper?*
### Conclusion

There's no security against Brute Force on IOT Devices credentials. You can either secure your devices placing them behind Firewalls and WAF, but you **MUST** use strong IOT Credentials.

## DOS Attack

### Prerequisite

First, we need to remove the authentication so we can connect as many clients as possible. To do so, change the **mosquitto.conf** from ```

```
allow_anonymous false
```

to ```
```
allow_anonymous true
```

Then, to start the DOS attack we will need to customize our messages payload. To do so, we will use [krylovsk/mqtt-benchmark's](https://github.com/krylovsk/mqtt-benchmark) tool. You can either build the application using GO (Linux) , or download the .exe in the [release](https://github.com/krylovsk/mqtt-benchmark/releases/tag/v0.2.0) tab (Windows).
### Attack

First, we start the Docker container using :

```
docker start <containerID>
```


Once downloaded, we can start using the **mqtt-benchmark** tool using this manual : 
``` shell
$ ./mqtt-benchmark -h
Usage of ./mqtt-benchmark:
  -broker string
    	MQTT broker endpoint as scheme://host:port (default "tcp://localhost:1883")
  -broker-ca-cert string
    	Path to broker CA certificate in PEM format
  -client-cert string
    	Path to client certificate in PEM format
  -client-key string
    	Path to private clientKey in PEM format
  -client-prefix string
    	MQTT client id prefix (suffixed with '-<client-num>' (default "mqtt-benchmark")
  -clients int
    	Number of clients to start (default 10)
  -count int
    	Number of messages to send per client (default 100)
  -format string
    	Output format: text|json (default "text")
  -insecure
    	Skip TLS certificate verification
  -message-interval int
    	Time interval in seconds to publish message (default 1)
  -password string
    	MQTT client password (empty if auth disabled)
  -payload string
    	MQTT message payload. If empty, then payload is generated based on the size parameter
  -qos int
    	QoS for published messages (default 1)
  -quiet
    	Suppress logs while running
  -ramp-up-time int
    	Time in seconds to generate clients by default will not wait between load request
  -size int
    	Size of the messages payload (bytes) (default 100)
  -topic string
    	MQTT topic for outgoing messages (default "/test")
  -username string
    	MQTT client username (empty if auth disabled)
  -wait int
    	QoS 1 wait timeout in milliseconds (default 60000)
```

For testing, we try this command : 
``` shell
./mqtt-benchmark --broker tcp://localhost:1883 --count 10 --size 100 --clients 10 --qos 2 --format text
```

And we get this output :

``` shell
======= CLIENT 2 =======
Ratio:               1.000 (10/10)
Runtime (s):         10.011
Msg time min (ms):   1.286
Msg time max (ms):   3.478
Msg time mean (ms):  1.918
Msg time std (ms):   0.710
Bandwidth (msg/sec): 0.999

======= CLIENT 3 =======
Ratio:               1.000 (10/10)
Runtime (s):         10.011
Msg time min (ms):   1.305
Msg time max (ms):   4.008
Msg time mean (ms):  1.936
Msg time std (ms):   0.850
Bandwidth (msg/sec): 0.999

... etc.
```

We see that our broker has no issue handling 10 clients that send 10 messages with a message payload of 100 Bytes.

When we use a payload size of 100MB, with a 100 clients that send 10 messages each, the container has trouble keeping up and crashes. We used this command :

``` shell
./mqtt-benchmark --broker tcp://localhost:1883 --count 10 --size 100000000 --clients 100 --qos 2 --format text
```

and got this output : 
``` shell
...
2023/09/06 15:43:38 CLIENT 84 is connected to the broker tcp://localhost:1883
2023/09/06 15:43:46 CLIENT 20 is connected to the broker tcp://localhost:1883
2023/09/06 15:43:46 CLIENT 13 is connected to the broker tcp://localhost:1883
Killed

$
```

Using an extension that monitors our container, we can see that the CPU is the point of failure here, but the memory can also be critical if there's not enough ressources allocated to the container.

This is the easiest implementation of the DOS Attack, but reading documentation we can create custom MQTT messages that uses the protocol's QoS to crash the container.

### Going Further

There was an update for MQTT brokers recently : 2.0.16 (16/08/2023) that fixed some issues about MQTT. Since it's recent, chances are most of the brokers are not updated, leaving huge risks for attackers.

For previous version, such as 2.0.15, there was a vulnerability that took advantage of MQTT QoS policy that causes the broker to memory leak. 

Put simply, clients could send multiple QoS 2 messages with the same message ID, but then never respond to the PUBREC commands from the broker, leaving the 4 time handshake waiting for an answer. [## CVE-2023-27366](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-27366)

This is maybe something that can be tested during IoT exercise, by manufacturing message payloads and not allowing the publisher to respond to PUBREC. ***scapy?***
